# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities import events, context

import requests
import random
import os
import base64
import hashlib
import time

class DefaultEventListener(EventListener):

    async def initialize(self):
        await super().initialize()
        
        @self.handler(events.NormalMessageResponded)
        async def handler(event_context):
            response_text = event_context.event.response_text
            print(f"ğŸ“ æ”¶åˆ°å›å¤æ–‡æœ¬: {response_text}")

            # è®¾ç½®TTSè§¦å‘æ¦‚ç‡ï¼ˆ100% = æ¯æ¬¡éƒ½ä¼šè¯­éŸ³å›å¤ï¼‰
            config = self.plugin.get_config()

            random_tts_probability = 100

            API_KEY = ""

            random_tts_probabilityt = config.get("random_tts_probability", 100)

            API_KEY = config.get("qhaitts_token", "")

            text = response_text

            voice = 'é­ˆ'

            voice = config.get("qhaitts_voicer", "é­ˆ")

            close_reply = True

            close_reply =  config.get("close_reply", True)

            if random.randint(1, 100) <= random_tts_probability:

                
                print(f"ğŸ¤ å¼€å§‹ç”Ÿæˆè¯­éŸ³ï¼Œä½¿ç”¨å£°çº¿: {voice}")
                result = self.download_audio_from_api(API_KEY, voice, text)
                
                if result and not result.startswith("âŒ"):
                    if close_reply == True:
                        event_context.prevent_default()
                    try:
                        # å‘é€è¯­éŸ³æ¶ˆæ¯
                        await event_context.reply(
                            platform_message.MessageChain([
                                platform_message.Voice(base64=result)
                            ])
                        )
                        print("âœ… è¯­éŸ³æ¶ˆæ¯å‘é€æˆåŠŸ")
                        
                        # æ¸…ç†ç¼“å­˜çš„è¯­éŸ³æ–‡ä»¶ï¼ˆå¦‚æœä½¿ç”¨äº†æ–‡ä»¶ç¼“å­˜ï¼‰
                        self.cleanup_audio_cache()
                        
                    except Exception as e:
                        print(f"âŒ è¯­éŸ³å‘é€å¤±è´¥: {e}")
                else: 
                    print(f"âŒ è¯­éŸ³ç”Ÿæˆå¤±è´¥: {result}")

    def download_audio_from_api(self, api_key: str, voice: str, text: str):
        """
        ç›´æ¥ä»APIä¸‹è½½éŸ³é¢‘å¹¶è¿”å›base64ç¼–ç 
        é¿å…åœ¨æœ¬åœ°åˆ›å»ºæ–‡ä»¶ï¼Œå‡å°‘ç¼“å­˜é—®é¢˜
        """
        headers = {
            'Authorization': f"Bearer {api_key}", 
            'Content-Type': 'application/json'
        }
        data = {
            "model": "qhai-tts",
            "input": text,
            "voice": voice,
            "response_format": "wav"  # æ˜ç¡®æŒ‡å®šæ ¼å¼
        }
        url = "https://api.qhaigc.net/v1/audio/speech"
        
        try:
            print(f"ğŸ”— è¯·æ±‚TTS APIï¼Œæ–‡æœ¬é•¿åº¦: {len(text)} å­—ç¬¦")
            response = requests.post(url, headers=headers, json=data, timeout=30)
            
            if response.status_code == 200:
                # å°†éŸ³é¢‘å†…å®¹è½¬æ¢ä¸ºbase64ç¼–ç 
                audio_base64 = base64.b64encode(response.content).decode('utf-8')
                print(f"âœ… éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼Œå¤§å°: {len(audio_base64)} å­—èŠ‚(base64)")
                return audio_base64
            else:
                error_msg = f"âŒ APIè¯·æ±‚å¤±è´¥: {response.status_code} - {response.text}"
                print(error_msg)
                return error_msg
                
        except requests.exceptions.Timeout:
            error_msg = "âŒ è¯·æ±‚è¶…æ—¶"
            print(error_msg)
            return error_msg
        except requests.exceptions.ConnectionError:
            error_msg = "âŒ ç½‘ç»œè¿æ¥é”™è¯¯"
            print(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"âŒ æœªçŸ¥é”™è¯¯: {str(e)}"
            print(error_msg)
            return error_msg

    def cleanup_audio_cache(self):
        """
        æ¸…ç†å¯èƒ½å­˜åœ¨çš„è¯­éŸ³ç¼“å­˜
        ç”±äºæˆ‘ä»¬ä½¿ç”¨base64ç›´æ¥å‘é€ï¼Œä¸ä¿å­˜æ–‡ä»¶ï¼Œè¿™é‡Œä¸»è¦æ¸…ç†å…¶ä»–å¯èƒ½çš„ç¼“å­˜
        """
        try:
            # æ£€æŸ¥ä¸´æ—¶ç›®å½•ä¸­å¯èƒ½å­˜åœ¨çš„è¯­éŸ³ç¼“å­˜æ–‡ä»¶
            temp_dir = "/tmp" if os.name != 'nt' else os.environ.get('TEMP', '')
            
            if temp_dir and os.path.exists(temp_dir):
                # æŸ¥æ‰¾å¯èƒ½çš„ç¼“å­˜æ–‡ä»¶ï¼ˆæŒ‰ä½ çš„å®é™…æƒ…å†µè°ƒæ•´ï¼‰
                for filename in os.listdir(temp_dir):
                    if filename.startswith("speech_") or filename.endswith(".wav"):
                        try:
                            filepath = os.path.join(temp_dir, filename)
                            # åªåˆ é™¤æ—§æ–‡ä»¶ï¼ˆè¶…è¿‡1å°æ—¶çš„ï¼‰
                            if time.time() - os.path.getmtime(filepath) > 3600:
                                os.remove(filepath)
                                print(f"ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜æ–‡ä»¶: {filename}")
                        except:
                            pass
        except Exception as e:
            print(f"âš ï¸ ç¼“å­˜æ¸…ç†æ—¶å‡ºé”™: {e}")

# å¦‚æœéœ€è¦æ–‡ä»¶ç¼“å­˜ç‰ˆæœ¬ï¼Œå¯ä»¥ä½¿ç”¨è¿™ä¸ªå‡½æ•°
def download_and_cache_audio(api_key: str, voice: str, text: str, cache_dir: str = "/tmp/tts_cache"):
    """
    å¸¦ç¼“å­˜åŠŸèƒ½çš„ç‰ˆæœ¬ï¼Œå‡å°‘APIè°ƒç”¨
    """
    # åˆ›å»ºç¼“å­˜ç›®å½•
    os.makedirs(cache_dir, exist_ok=True)
    
    # ç”Ÿæˆæ–‡æœ¬çš„hashä½œä¸ºæ–‡ä»¶å
    text_hash = hashlib.md5(text.encode()).hexdigest()
    cache_file = os.path.join(cache_dir, f"{voice}_{text_hash}.wav")
    
    # æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
    if os.path.exists(cache_file):
        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸï¼ˆä¾‹å¦‚24å°æ—¶ï¼‰
        if time.time() - os.path.getmtime(cache_file) < 86400:
            print(f"ğŸ“ ä½¿ç”¨ç¼“å­˜æ–‡ä»¶: {cache_file}")
            with open(cache_file, 'rb') as f:
                return base64.b64encode(f.read()).decode('utf-8')
    
    # æ²¡æœ‰ç¼“å­˜æˆ–å·²è¿‡æœŸï¼Œè°ƒç”¨API
    headers = {'Authorization': f"Bearer {api_key}", 'Content-Type': 'application/json'}
    data = {"model": "qhai-tts", "input": text, "voice": voice}
    url = "https://api.qhaigc.net/v1/audio/speech"
    
    try:
        response = requests.post(url, headers=headers, json=data, timeout=30)
        
        if response.status_code == 200:
            # ä¿å­˜åˆ°ç¼“å­˜
            with open(cache_file, 'wb') as f:
                f.write(response.content)
            
            # æ¸…ç†æ—§ç¼“å­˜ï¼ˆä¿æŒæœ€å¤š50ä¸ªæ–‡ä»¶ï¼‰
            cache_files = [os.path.join(cache_dir, f) for f in os.listdir(cache_dir)]
            cache_files.sort(key=lambda x: os.path.getmtime(x))
            while len(cache_files) > 50:
                try:
                    os.remove(cache_files[0])
                    cache_files.pop(0)
                except:
                    pass
            
            return base64.b64encode(response.content).decode('utf-8')
        else:
            return f"âŒ ä¸‹è½½å¤±è´¥: {response.status_code}"
            
    except Exception as e:
        return f"âŒ é”™è¯¯: {e}"